---
title: "Simulating waiting lists"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulating waiting lists}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 3,
  fig.width = 6
)
```

```{r setup}
library(NHSRwaitinglist)
library(ggplot2)

theme_set(
  theme_minimal() +
    theme(
      plot.subtitle = element_text(face = "italic")
    )
)
```

# Introduction
When working with waiting lists, we may start with trying to understand current burdens, demand, capacity, load etc.  If we have a planning dimension to our work, we may also want to ask 'what if....' or 'how long until...' questions of our waiting list.  Simulation, based on the properties of our waiting lists (or assumptions about how they will change), allows us to ask these questions and test out hypotheses.

The following vignette acts as an example, where we are are modelling a waiting list for a UK NHS hospital for a surgical speciality.  The process might have the flow such as: 

* a patient presents to General Practise (GP)
* a GP refers the patient a hospital 'outpatients clinic'
* the clinician in the clinic lists the patient for surgery (entering the waiting list)
* Once the patient has receive their surgery, they leave the waiting list. We will consider this against an 18 week standard for waiting times. 

### Sceanrios

We will imagine three scenarios below, where we want to simulate into the future:

1. where we need to bring a high waiting list down into control
2. where our waiting list can afford to grow (e.g. we want to constrain capacity, such as sub-contracted care at other organisations)
3. how our list will change with predicted population/referral growth and a service change


__Please remember that the examples here are simulations.  They will vary due to chance each time they are run, and that is their strength.  Do not expect to get exactly the same result when repeating; expect to get the same average results.__

The final example will discuss estimating uncertainty in these simulations through Monte Carlo methods.


# Set-up
[Back to top...](#)

We will imagine a surgical treatment speciality at a UK NHS hospital. The NHS standard for this waiting list is to have 92% of patients seen and treated by 18 weeks. 

Using the `NHSRwaitinglist` package, we can calculate a few important statistics for different scenarios, starting required main waiting time to meet our target:

```{r overview}
# What is the quantile value for target waiting list,
# based on 92% of exponential distribution
qt92 <- qexp(0.92)

# Target mean wait for 18 weeks
target_mean_wait <- calc_target_mean_wait(18, qt92)
target_mean_wait
```
This makes our target average wait `r target_mean_wait` weeks, and this average is regardless of demand/capacity queue size.  The average wait must be this value, or less to meet 92% at 18 weeks.



# 1. Bringing down a waiting list
[Back to top...](#)

For our first scenario, let's assume the service received 100 weekly referrals and has a weekly capacity of 80 appointments.  We describe this balance between demand and capacity as the 'Load', which is the ratio between demand and capacity: 100/80= 1.25.  If the Load is greater than 1, then the waiting list will grow, and if it is less than 1 the waiting list will reduce.
Let's imagine our service is already running with a waiting list of 840.  There are few ways to set this up, including supplying a real waiting list, simulate/generate it using the properties of the list, or we can manually dump a load of open pathways into the start of the simulation.  


Below we simulate one based on knowing the 840 on this list, and 20 more referrals than removals per week (difference in demand and capacity) adds 20 to the waiting list each week.  If we divide the 840 on the waiting list by 20, we get 42 weeks.  We need to run the simulation for 42 weeks (with the stated demand and capacity to generate a waiting list of 840). ___Remember that this is simulation, so it is stochastic.  Any two runs will not be identical, but will lead to 840 on list on average.___

```{r sim_wl_setup}
end_date <- as.Date("2023-03-31")

# WL is 200, simulation is weekly, and capacity / demand difference is 20,
# 20 added to WL each week. Therefore 420 / 20 = 21, 21 week difference for
# sim start and end date:  7 x 21 = 147 days.
# We take 1 day away too, to discount the end_date

start_date <- end_date - (((840 / 20) * 7) - 1)

current_wl1 <- wl_simulator(start_date = start_date,
                            end_date = end_date,
                            demand = 100,
                            capacity = 80)

tail(wl_queue_size(current_wl1))
```


Below, we manually dump 840 open pathways into the sim the day before our start.
```{r dump_wl_setup}
current_wl1 <-
  data.frame(
    Referral = rep(as.Date("2023-03-31"), 840)
    , Removal = rep(as.Date(NA), 840)
  )

# Only a single day in our waiting list so we don't need `tail()` this time
wl_queue_size(current_wl1)
```

## What is the target for this service?

If we are governing our resources well, we want to allow a sustainable queue as this allows people to be flexibly scheduled whilst still meeting our targets.  All capacity comes at a cost to the system, so we are seeking a balance between demand and capacity with a sustainable waiting list.

So our question is: what is the sustainable queue size for delivering 92% at 18 weeks, given 100 weekly demand.

```{r target1}
target_queue1 <- calc_target_queue_size(demand = 100, 
                                        target_wait = 18, factor = qt92)
target_queue1
```

We have a target queue size of `r target_queue1`, and currently running a waiting list in excess of this, and load is >1, so the list will keep growing, without intervention, and average wait times will get longer.

## Options for management

There are two ways to bring a waiting list like this down:
1. Raise the capacity ("more flowing out")
2. Reduce the demand ("fewer flowing in")

### Raising capacity

Let's imagine we are able to put an additional clinic in place that offers 25 more slots per week, taking our waiting list pressure down. We need to remember to include our waiting list into the simulation function, so it does not start from zero.  We will run the simulation for a two year period then plot the waiting list.

```{r sim_raise_capacity}
raised_capacity_wl <-
  wl_simulator(start_date = as.Date("2023-04-01"),
               end_date = as.Date("2024-03-31"),
               demand = 100,
               capacity = 105,
               waiting_list = current_wl1)

raised_capacity_queue <- wl_queue_size(raised_capacity_wl)

tail(raised_capacity_queue)
```

To visualise this, we will plot the queue against time, marking the target queue size.

```{r plot_raise_capacity, message=FALSE, warning=FALSE}
ggplot(raised_capacity_queue, aes(y = queue_size, x = dates)) +
  geom_line() +
  geom_hline(yintercept = target_queue1, colour = "#440154FF") +
  annotate("text", label = "Target queue size", x = as.Date("2024-03-31")
           , y = target_queue1, vjust = 1.2
           , hjust = 1.2, colour = "#440154FF") +
  labs(y = "Queue Size", x = "Date"
       , title = "Simulated waiting list after raising capacity")
  
```
The simulation above suggests that, maintaining the extra clinic until the end of the year (31st December), would return the waiting list to just below the sustainable target.


## 2. Our waiting list can afford to grow
[Back to top...](#)

On the surface, we might assume that growing a waiting list is always a bad thing.  When dealing with a health economy, we must consider the ['opportunity cost'](https://en.wikipedia.org/wiki/Opportunity_cost): what benefits we forgo by using our resources in one place rather than another.  This could mean that, we increase a waiting list, within an acceptable limit and release resources/staff/funding to be used elsewhere.

In this scenario, we will consider a system with 50 referrals per week, 50 capacity per week, and a current waiting list of 82.  We have a queue load of 1, so baring natural fluctuation, we would not expect our queue to grow or reduce.
We, again, have the same target of 92% within 18 weeks (as per example 1).  This means our target average waiting time would be `r target_mean_wait`.  We will

Let's first calculate our target queue length:

```{r target2}
target_queue2 <- calc_target_queue_size(demand = 50
                                        , target_wait = 18, factor = qt92)
target_queue2
```

Our current waiting list is 82, with a target of: `r target_queue2`.  This means we can afford to let our queue size increase to `r target_queue2 - 82`.

If we are willing to let our waiting list grow over the next 6 months, this equates to:

```{r list_growth_2}
current_queue <- 82 
queue_growth <- target_queue2 - current_queue
weeks_to_grow <- 26 #52 weeks per year / 2 for 6 months

queue_growth / weeks_to_grow

```

We can then assume that we can reduce capacity by `r queue_growth / weeks_to_grow` per week, and allow the queue to grow.
If this number is a decimal, it is sensible to make the conservative rounding choice that leads to the lower queue growth.  In this case it is to `floor()` the growth to `r floor(queue_growth / weeks_to_grow)`.

We can then verify it using simulation, following the steps in example 1.: set up the waiting list, then simulate with our parameters:

```{r example_2}
current_wl2 <- data.frame(Referral = rep(as.Date("2024-03-31"), current_queue)
                          , Removal = rep(as.Date(NA), current_queue)
)

raise_wl_sim <- 
  wl_simulator(start_date = as.Date("2024-04-01"),
               end_date = as.Date("2024-09-30"),
               demand = 50,
               capacity =  (50 - 10), # 10 = floor(queue_growth / weeks_to_grow)
               waiting_list = current_wl2)

raised_wl <- wl_queue_size(raise_wl_sim)

ggplot(raised_wl, aes(y = queue_size, x = dates)) +
  geom_line() +
  geom_hline(yintercept = target_queue2, colour = "#21908CFF") +
  annotate("text", label = "Target queue size", x = as.Date("2024-04-01")
           , y = target_queue2, vjust = 1.2, hjust = 0, colour = "#21908CFF") +
  labs(y = "Queue Size", x = "Date"
       , title = "Simulated waiting list after allowing waiting list to grow")
```


# 3. How our list will change with predicted population/referral growth

This more complex example, and we will make two assumptions over a 5-year modelling period:

1. That referrals will grow 5% per year
2. In year 3, a service change will come into place that removes 20% of the referrals.

To simulate this, we will need to set up our data inputs to reflect the assumptions.
We will set up a scenario starting with 100 referrals per week, 100 capacity per week, and a waiting list of 500.
We will do our range calculations for the sustainable lists, assuming a slightly different target from the first 2 examples: 95% should be seen within 18 weeks.

```{r target3}
# Target mean wait for 95% at 18 weeks
target_mean_wait3 <- calc_target_mean_wait(18, qexp(0.95))
target_mean_wait3

target_queue3 <- calc_target_queue_size(demand = 100, 
                                        target_wait = 18, factor = qexp(0.95))
target_queue3
```

In this case ours sustainable waiting list is `r target_queue3`, but this is only true at the start of the period. Given our growth and change assumptions, we need to construct a control table that maps these values out to power the simulation.  This is worked out below in R, but users may find it easier to build in a spreadsheet application.

```{r control_table}
ctrl_tbl <- data.frame(
  start_date = as.Date(c("2024-04-01", "2025-04-01", "2026-04-01"
                         , "2027-04-01","2028-04-01"), format = "%Y-%m-%d"),
  end_date = as.Date(c("2025-03-31", "2026-03-31", "2027-03-31"
                       , "2028-03-31", "2029-03-31"), format = "%Y-%m-%d"),
  demand = 100,
  capacity = 100
)

# Manually setting sim properties to illustrate:
ctrl_tbl$demand[2] <- ctrl_tbl$demand[1] * 1.05
ctrl_tbl$demand[3] <- (ctrl_tbl$demand[2] * 1.05) * 0.8 # 5% growth, 20% reduction from intervention
ctrl_tbl$demand[4] <- ctrl_tbl$demand[3] * 1.05
ctrl_tbl$demand[5] <- ctrl_tbl$demand[4] * 1.05

ctrl_tbl
```

We also need to update target queue size.  We could do this by setting based on the current demand, the yearly demand or by the anticipated demand at the last period.  Here, we will take the second approach, but this requires a calculation for each row.

```{r target_queue_size_dynamic}
ctrl_tbl$target_queue_size <- calc_target_queue_size(demand = ctrl_tbl$demand
                                                     , target_wait = 18
                                                     , factor = qexp(0.95))
```

```{r setup_wl_3}
current_wl3 <- 
  data.frame(Referral = rep(as.Date("2024-03-31"), 500)
             , Removal = rep(as.Date(NA), 500)
             )

```


We then run the first line of the table through the simulation. with the current waiting list: 

```{r sim3_1}
sim3_period1 <-
  wl_simulator(start_date = ctrl_tbl$start_date[1]
               , end_date = ctrl_tbl$end_date[1]
               , demand = ctrl_tbl$demand[1]
               , capacity = ctrl_tbl$capacity[1]
               , waiting_list = current_wl3)
```

We can now loop through the rest of the table using a mechanism such as a loop:

```{r sim3_loop}
# Loop through and simulate each section
# Loop pick up each previous waiting list
# using the 'eval(call("<-")...) allows dynamic naming for each loop
for (i in seq(2, 5)) {
  eval(
    call("<-"
         , as.name(paste0("sim3_period",as.character(i)))
         , wl_simulator(start_date = ctrl_tbl$start_date[i]
                        , end_date = ctrl_tbl$end_date[i]
                        , demand = ctrl_tbl$demand[i]
                        , capacity = ctrl_tbl$capacity[i]
                        , waiting_list = get(paste0("sim3_period", as.character(i - 1))))
    )
  )
  
}

queue_over_time <-  wl_queue_size(sim3_period5)
```

We can now plot and see what our list looks like.  Key points to note are:
* The target queue size is calculated at each `start_date`, i.e. 1st April, and the way the lines are draw connects this points with a straight line.
* Depending on the variation in the simulation, the waiting list peaks above the sustainable target value in 2025/26, before the demand reduction pulls this list back down to a sustainable size.

```{r plot3}
ggplot(queue_over_time, aes(y = queue_size, x = dates)) +
  geom_line() +
  geom_line(aes(y = target_queue_size , x = start_date)
            , colour = "#A69D75FF"
            , data = data.frame(
              target_queue_size = c(ctrl_tbl$target_queue_size, ctrl_tbl$target_queue_size[5]),
              start_date = c(ctrl_tbl$start_date, ctrl_tbl$end_date[5])
            )
  )+
  annotate("text", label = "Target queue size", x = ctrl_tbl$start_date[5]
           , y = ctrl_tbl$target_queue_size[5], vjust = 1.2, hjust = 0, colour = "#A69D75FF") +
  geom_vline(xintercept = as.Date("2026-04-01"), colour = "red") +
  annotate("text", label = "20% demand\nreduction", x = as.Date("2026-04-01")
           , y = 200, hjust = 1.1, colour = "red") +
  labs(y = "Queue Size", x = "Date", title = "Simulated waiting list, 5% year on year growth."
       , subtitle = "20% demand reduction from Apr-2026")

```


# 4. Estimating uncertainty via Monte Carlo methods
[Back to top...](#)

The examples above have shown how we can simulate waiting lists, but each is a single simulation run based on random draws from a distribution.  They change each time due to change, but in a predictable way.  We can get an idea of the uncertainty around the methods above by using Monte Carlo methods: running them repeatedly and averaging over the values.

Using example 1., we can repeatedly run it in several ways. This method wraps the simulation and the queue size functions in inside a function.  This means that each run will return a data.frame of daily queue sizes.


```{r montecarlo_1}
sim_func <- function(){
  sim <- wl_simulator(start_date = as.Date("2023-04-01"),
                      end_date = as.Date("2024-03-31"),
                      demand = 100,
                      capacity = 105,
                      waiting_list = current_wl1)
  wl_queue_size(sim)
}

raised_capacity_wl_mc <- 
  replicate(50, sim_func(), simplify = FALSE)
```

The replicate function above runs the simulation 50 times, and returns a list of the 50 replicates.  We then need to reformat this list and chose how we will average over the events.  In the example below, I pull it into a single table then aggregate by average values per day.  This will not always be the right approach, but it depends on your question.  In this case, it helps give a more robust estimate of the average effects and allows us to put percentile or confidence interval ranges around them.

```{r montecarlo_2}
mc_bind <- do.call("rbind", raised_capacity_wl_mc)
mc_agg <- aggregate(queue_size~dates, data = mc_bind
                    , FUN = \(x)
                    c(mean_q = mean(x),
                      median_q = median(x),
                      lower_95CI = mean(x) -
                        (qnorm(0.975) * (sd(x)/sqrt(length(x)))),
                      upper_95CI = mean(x) +
                        (qnorm(0.975) * (sd(x)/sqrt(length(x)))),
                      q_25 = quantile(x, .025, names = FALSE), 
                      q_75 = quantile(x, .975, names = FALSE))
)
mc_agg <- data.frame(dates=as.Date(mc_agg$dates), unlist(mc_agg$queue_size))
```


We can now produce a similar plot to the one in section 1, but using the average value and 95% confidence interval.

```{r montecarlo_3}
ggplot(mc_agg, aes(y = mean_q, x = dates)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower_95CI, ymax = upper_95CI)
              , alpha = 0.5, linetype = "dotted") +
  geom_hline(yintercept = target_queue1, colour = "#440154FF") +
  annotate("text", label = "Target queue size", x = as.Date("2024-03-31")
           , y = target_queue1, vjust = -1, colour = "#440154FF") +
  labs(y = "Queue Size", x = "Date"
       , title = "Simulated waiting list after raising capacity"
       , subtitle = "Average WL over 50 runs, with 95% confidence interval")
```

The averaging has led to a straighter line for the trend and we have a range of uncertainty around the projection. Alternatively we could present the 25th - 75% percentile range.  This type of Monte Carlo process can be applied to various situation by building your simulation into a function, repeatedly executing it (which could be in parallel), results are collected and summary data calculated.
